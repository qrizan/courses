create new environtment 
virtualenv venv

activate env
. venv/bin/activate
deactivate

structure file like this:

├── app
│   ├── __init__.py
│   ├── models.py
│   ├── routes.py
│   └── templates
├── config.py
├── requirements.txt
└── run.py


#DATABASE

install sqlalchemy
pip install flask-sqlalchemy

pip install mysqlclient

create courses_db in mysql 
mysql> CREATE DATABASE courses_db;
Query OK, 1 row affected (0,00 sec)

mysql> 



add code in config.py
It is good practice to specify configurations for different environments

class Config(object):


class DevelopmentConfig(Config):
    DEBUG = True
    SQLALCHEMY_ECHO = True


class ProductionConfig(Config):
    DEBUG = False

app_config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig
}



create instance directory and put this code 
# instance/config.py

SECRET_KEY = 'p9Bv<3Eid9%$i01'
SQLALCHEMY_DATABASE_URI = 'mysql://username:password@localhost/courses_db'

alternate create secret key in python console
>>> import secrets
>>> secrets.token_hex(16)
'0e4cf9a00d41eec96d7eaf326769cc62'
>>> 


add code below in app/__init__.py

We've created a function, create_app that, given a configuration name, loads the correct configuration from the config.py file, as well as the configurations from the instance/config.py file. We have also created a db object which we will use to interact with the database.

# app/__init__.py

# third-party imports
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

# local imports
from config import app_config

# db variable initialization
db = SQLAlchemy()

def create_app(config_name):
    app = Flask(__name__, instance_relative_config=True)
    app.config.from_object(app_config[config_name])
    app.config.from_pyfile('config.py')
    db.init_app(app)

    return app



edit run.py file
# run.py

import os

from app import create_app

config_name = os.getenv('FLASK_CONFIG')
app = create_app(config_name)


if __name__ == '__main__':
    app.run()


===================================
$ . env/bin/activate
(env) $ export FLASK_APP=run.py
(env) $ printenv FLASK_APP
run.py
(env) sudo flask run
===================================


config in linux terminal
export FLASK_APP=flask
export FLASK_ENV=development
printenv FLASK_APP
printenv FLASK_ENV
flask run
 * Serving Flask app "flask" (lazy loading)
 * Environment: development
 * Debug mode: on
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!


#MODELS
install flask login
pip install flask_login

create a LoginManager object and initialize it in the app/__init__.py file

# app/__init__.py

# after existing third-party imports
from flask_login import LoginManager

# after the db variable initialization
login_manager = LoginManager()


def create_app(config_name):
    # existing code remains

    login_manager.init_app(app)
    login_manager.login_message = "You must be logged in to access this page."
    login_manager.login_view = "auth.login"

    return app



add the following code to the app/models.py file

# app/models.py
# Ensures table will be named in plural and not in singular

from flask_login import UserMixin
from werkzeug.security import generate_password_hash, check_password_hash
from app import db, login_manager

class Student(UserMixin, db.Model):
    # create a Student table
    __tablename__ = 'students'

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(60), index=True, unique=True)
    email = db.Column(db.String(20),unique=True,nullable=False)
    image_profile = db.Column(db.String(20),nullable=False, default='profile-default.png')
    password_hash = db.Column(db.String(128))
    lesson_id = db.Column(db.Integer, db.ForeignKey('lessons.id'))
    role_id = db.Column(db.Integer, db.ForeignKey('roles.id'))
    is_admin = db.Column(db.Boolean, default=False)

    @property
    def password(self):
        # password from being accessed
        raise AttributeError('password is not a readable attribute.')

    @password.setter
    def password(self, password):
        #hashed password
        self.password_hash = generate_password_hash(password)

    def verify_password(self, password):
        # hashed password matches actual password
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return '<Student: {}>'.format(self.username)


# Set up user_loader
@login_manager.user_loader
def load_user(user_id):
    return Student.query.get(int(user_id))


class Lesson(db.Model):
    # create a Lesson table
    __tablename__ = 'lessons'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(60), unique=True)
    description = db.Column(db.String(200))
    image_banner = db.Column(db.String(20),nullable=False, default='banner-default.png')
    students = db.relationship('Student', backref='lesson',lazy='dynamic')

    def __repr__(self):
        return '<Lesson: {}>'.format(self.name)


class Role(db.Model):
    # create a Role table
    __tablename__ = 'roles'

    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(60), unique=True)
    description = db.Column(db.String(200))
    students = db.relationship('Student', backref='role',lazy='dynamic')

    def __repr__(self):
        return '<Role: {}>'.format(self.name)




install flask migrate
pip install flask-migrate


edit app/__init__.py

# app/__init__.py

# after existing third-party imports
from flask_migrate import Migrate

# existing code remains


def create_app(config_name):
    # existing code remains

    migrate = Migrate(app, db)

    from app import models

    return app


created a migrate object
flask db init
flask db migrate
flask db upgrade


from app import db, create_app

check database
$ mysql -u root -p
Enter password: 

mysql> use courses_db;
Reading table information for completion of table and column names
You can turn off this feature to get a quicker startup with -A

Database changed
mysql> show tables;
+----------------------+
| Tables_in_courses_db |
+----------------------+
| alembic_version      |
| lessons              |
| roles                |
| students             |
+----------------------+
4 rows in set (0,00 sec)



Blueprints

create admin,auth, home directory in app
create routes.py in each directory

create file __init__.py

# app/admin/__init__.py

from flask import Blueprint

admin = Blueprint('admin', __name__)

from . import routes



# app/auth/__init__.py

from flask import Blueprint

auth = Blueprint('auth', __name__)

from . import routes



# app/home/__init__.py

from flask import Blueprint

home = Blueprint('home', __name__)

from . import routes



register the blueprints on the app in the app/__init__.py

# app/__init__.py

# existing code remains


def create_app(config_name):
    # existing code remains

    from app import models

    from .admin import admin as admin_blueprint
    app.register_blueprint(admin_blueprint, url_prefix='/admin')

    from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint)

    from .home import home as home_blueprint
    app.register_blueprint(home_blueprint)

    return app



add code in routes.py in home directory

# app/home/routes.py

from flask import render_template
from flask_login import login_required

from . import home

@home.route('/')
def homepage():
    # render the homepage template
    return render_template('home/index.html', title="Welcome")


@home.route('/dashboard')
@login_required
def dashboard():
    # render the dashboard template
    return render_template('home/dashboard.html', title="Dashboard")



Auth Blueprint

install flask-WTF
pip install Flask-WTF


create forms.py in directory app/auth/

# app/auth/forms.py

from flask_wtf import FlaskForm
from wtforms import PasswordField, StringField, SubmitField, ValidationError
from wtforms.validators import DataRequired, Email, EqualTo

from ..models import Employee


class RegistrationForm(FlaskForm):
    """
    Form for users to create new account
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    username = StringField('Username', validators=[DataRequired()])
    first_name = StringField('First Name', validators=[DataRequired()])
    last_name = StringField('Last Name', validators=[DataRequired()])
    password = PasswordField('Password', validators=[
                                        DataRequired(),
                                        EqualTo('confirm_password')
                                        ])
    confirm_password = PasswordField('Confirm Password')
    submit = SubmitField('Register')

    def validate_email(self, field):
        if Employee.query.filter_by(email=field.data).first():
            raise ValidationError('Email is already in use.')

    def validate_username(self, field):
        if Employee.query.filter_by(username=field.data).first():
            raise ValidationError('Username is already in use.')


class LoginForm(FlaskForm):
    """
    Form for users to login
    """
    email = StringField('Email', validators=[DataRequired(), Email()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')


edit file app/auth/routes.py

# app/auth/routes.py

from flask import flash, redirect, render_template, url_for
from flask_login import login_required, login_user, logout_user

from . import auth
from forms import LoginForm, RegistrationForm
from .. import db
from ..models import Student


@auth.route('/register', methods=['GET', 'POST'])
def register():
    # add an Student to the database through the registration form
    form = RegistrationForm()
    if form.validate_on_submit():
        student = Student(email=form.email.data,
                          username=form.username.data,
                          first_name=form.first_name.data,
                          last_name=form.last_name.data,
                          password=form.password.data)

        # add employee to the database
        db.session.add(student)
        db.session.commit()
        flash('You have successfully registered! You may now login.')

        # redirect to the login page
        return redirect(url_for('auth.login'))

    # load registration template
    return render_template('auth/register.html', form=form, title='Register')


@auth.route('/login', methods=['GET', 'POST'])
def login():
    # log an student in through the login form
    form = LoginForm()
    if form.validate_on_submit():

        # check student exists in the database
        student = Student.query.filter_by(email=form.email.data).first()

        # the password entered matches the password in the database
        if student is not None and student.verify_password(form.password.data):
            # log employee in
            login_user(student)

            # redirect to the dashboard page after login
            return redirect(url_for('home.dashboard'))

        # when login details are incorrect
        else:
            flash('Invalid email or password.')

    # load login template
    return render_template('auth/login.html', form=form, title='Login')


@auth.route('/logout')
@login_required
def logout():
    # handle requests to the /logout route
    logout_user()
    flash('You have successfully been logged out.')

    # redirect to the login page
    return redirect(url_for('auth.login'))



custome template 
navbar current_user
responsive

Admin User

creating an admin user through the command line

$ flask shell
>>> from app.models import Student
>>> from app import db
>>> admin = Student(email="admin@admin.com",username="admin",password="admin",is_admin=True)
>>> db.session.add(admin)
>>> db.session.commit()




Admin Dashboard

